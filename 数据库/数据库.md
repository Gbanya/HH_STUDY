##数据库类型
  - 关系型：用于描述`实体与实体`之间的关系[实实在在的事物，老师学生等]，`以表的形式体现`。Mysql,Oracle,DB2等。`支持事务`
  - 非关系型：用`key:value`的形式描述数据关系,radis,mongodb,`不支持事务`

##E-R关系图
  - 实体联系【Entity-Relation】图，用图形来表示各实体之间的关系
    ```
    实体---方框
    属性---椭圆
    关系---菱形
    ```
##sql语句
  - DDL(Data define language)数据定义语言：<br>
  数据库/表的增删改：create,drop/truncate,alter
  改表结构：alter table xx add/modify/drop...
  - DML(Data manipulate language)数据操作语言:<br>
  增删改表数据：insert into,delete,update
  - DQL(Data query language)数据查询语言<br>
  表内容查询：select
  - DCL(Data Control Language)数据控制语言<br>
  控制用户权限
  ```
  1)DDL:
    |-库
      a、创建：指定了字符集合和校对规则
        create database db1 charset utf8 collate utf8_bin;
      b、删除：
        drop database db1;
      c、修改：修改其字符集
       alter database db1 charset gbk;
      d、查看：
        show create database db1;[查看创建的db1的库定义]
        show database;[查看有哪些库]
        select database();[查看当前选中的库]
        *特殊*：use db1;[使用db1库]
    |-表:
      表的创建：不要有NULL，每个字段最后都添加COMMENT ''[备注]
      a、创建：
        create table flower(
            id int(10) NOT NULL PRIMARY KEY AUTO_INCREAMENT COMMENT '编号',
            name char(20) NOT NULL COMMENT '花名',
            price char(20) NOT NULL COMMENT '价格'
        )
      b、删：
        drop table test1;
        truncate table test1;
        --drop、delete和truncate三者的区别--
          a、三两者都能实现删除表数据的功能
          b、delete和truncate都是删除表数据而不删除结构(清空)，drop会删除表结构
          c、delete是逐行删除表中数据，而truncate是删除表，再创建一张内容格式与之相同的空白表
          delete不会清空主键id值，truncate会清空
          delete用于数据较少时，truncate用于数据较多的时候。delete会受到sql语句条件的影响，比如where等
  
      c、改：
        alter table test1 charset utf8;[改表的字符集]
        rename table test1 to test2;[改表的名字]
        [表增加字段]
        alter table test1 add 字段名 字段类型 字段约束;
        [表修改字段属性]
        alter table test1 modify 字段名 字段类型 字段约束;
        [表修改字段名]
        alter table test1 change 旧字段名 新字段名 字段类型 字段约束;
        [删除字段]
        alter table test1 drop 字段名;
  
      d、查：
        show create table test1;[查看创建的表test1的定义]
        show tables[查看所有的表]
        desc test1[查看表test1结构]
  
    2)、DML：
      |-表中的数据：
      a、增：
        insert into test1(字段名1,字段名2..) values(值1,值2..);//值与数据11对应，可以插入部分值
        [全部数据插入的简单写法：]
        insert into test1 values(值1,值2..);
        [批量插入，只能是全插的情况下：]
        insert into test1 values(null,'测试1',..),(null,'测试2'..),...
  
      b、删：
        delete from test1;[删除所有数据]
        delete from test1 where 条件;[删除条件的数据，eg：where id = 9]
  
      c、改：
        update test1 set 字段名1=值1,字段名2=值2.. where 条件;
  
    3)、DQL:
      |-表中的数据--查：
      【任意的查询结果表示方式：】
        select .. from 表名 ..[前面可以是聚合函数、字段，后面可以跟条件]
        a、别名查询：
        【表取别名】
          select t1.tid,t1.tname from test1 as t1;
        【列取别名】
          select tid, tname as 测试名 from test1 where tid = 1;
        b、【去重查询】
          select tid, distinct tname from test1;
        c、运算查询
          select pname,price*0.8 as 折后价 from category;
        d、简单查询
          select .. from test1 where 运算符条件;
        e、复杂查询
          --模糊查询：like ''--
          '%'：代表多个字符，eg：坚挺哥药丸->'%挺%',坚挺->'坚挺';
          '_'：代表一个字符，eg：牛逼哥口服液->'_逼%'或者'%逼%';
          select pid,pname from category from where pname like'%挺%';//名字中间带'挺'的;
          select pid,pname from category from where pname like'_逼%';//第二个字为'逼'的;
          --范围查询：in()--
          select pid,pname from category where pid in(1,3,4);
          --排序查询：order by 字段名 asc(升序)/desc(降序)--
          //商品表中查询出价格大于50的并按序号升序排列
          select pid,pname from category where price>50 order by pid asc;
          --聚合查询：提供聚合函数sum(),avg(),count(),max(),min()--
          --子查询：查询嵌套，将一个查询结果作为另一个查询的条件--
          //查询出价格大于平均价格的商品
          select pid,price,pname,properties from category where price>(select avg(price) from category);
          --分组查询group by 字段名--
          分组查询后跟having可以对查询结果进行二次筛选。
          select avg(price) from category group by cno having avg(price)>60;
          注：*having与where不能在同一次查询中出现*
            a、如果不涉及到分组，通常用where：
            b、如果【涉及到分组】，且对分组结果进行2次查询：group by + having 二次查询条件
            其中：
              where是在 查询前做条件限制，返回结果
              having是在 查询后的结果集上做条件限制，进行结果的筛选，因此通常选用where效率要高
          --分页查询--
          select * from test1 limit offset,pageSize;
            offset = (第几页-1)*n;
            pageSize = 每页显示的个数
            
  ```
##多表查询
  - 一对多：一的1方是主表，添加主键约束。多的1方是从表，添加外键约束；一的1方的外键指向多的1方的主键
  - 多对多：添加一张中间表，该表至少2个外键分别指向两张表的主键。同时,中间表的的两个外键之间存在联合主键
  - 表间约束：
    ````
    主键约束：primary key;   
    自动增长约束：auto_increment
    外键约束：foregin key(外键字段) reference to 主表名(主键约束的字段)
    唯一约束：unique
    默认约束：default
    非空约束：not null
    ```
  - 内连接、外连接
    - 内连接：保证两个表中所有的行都要满足连接条件，而查询出结果，而外连接则不然。
    - 外连接中，某些不满条件的列也会显示出来，即只限制一个表的行，而不限制另一个表的行。若在`另一方表中无数据，以null显示`
      - 左连接：<br>
      Select *(属性) from A left join B on 条件；以左A表为基准查询右B表。
      - 右连接：<br>
      Select *(属性) from A right join B on 条件; 以右A表为基准去查询左B表<br>
      `注：左右连接都是外连接，两表联合查询条数一样，不足以null补齐`