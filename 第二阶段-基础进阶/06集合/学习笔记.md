#### 集合

1. 集合

   - 长度可以变化（数组不可变），**只能存对象**（数组可以存基本类型和对象）

   - Collection集合的框架

     ![集合框架](D:\HH_STUDY-test\基础知识加强版\06集合\学习笔记.assets\集合框架.png)

   - collection集合常见功能

     ```java
     Collection<String> c1 = new ArrayList<>();//多态
     System.out.println(c1);//重写了toString方法
     //添加元素，返回值是布尔值，可以不用接收
     c1.add("张三");
     c1.add("李四");
     c1.add("王五");
     c1.add("田七");
     System.out.println(c1);
     //删除
     c1.remove("张三");
     //包含
     System.out.println(c1.contains("张三"));
     System.out.println(c1.contains("李四"));
     //判断是否为空
     System.out.println(c1.isEmpty());
     //返回元素个数
     System.out.println(c1.size());
     //变成数组
     Object[] obj = c1.toArray();
     for (int i = 0; i < obj.length; i++) {
           System.out.println(obj[i]);
       }
     c1.clear();
     ```
   
2. **Iterator<>接口**（迭代器）：通用的取出集合元素的方式

   - 获取实现方式：collection中的iterator（）方法，这个方法返回的是**迭代器的实现类对象**

   - 使用步骤：

     - 使用集合中的方法获取对象，用Iterator来接收（多态）

     - 判断hasNext()?

     - 有就取出 Next()

     - 注意这个接口也是有泛型的

     - 增强for循环（前面学数组时用过）

       ```java
       Iterator<String> iterator = c1.iterator();//获取迭代器
       while (iterator.hasNext()){
           System.out.println(iterator.next());
          }
       //增强for循环用于遍历数组和集合
       for(String a:c1){
           System.out.println(a);
          }
       ```

3. 泛型

   - 集合不使用泛型时，默认的类型是object，可以添加任意类型的数据，但是会**引发类型转换异常**！

   - 把运行期异常（运行时异常）提升到了编译期（写代码时会报错）

   - 定义含有泛型的类和方法

     ```java
     //修饰符 class 类名<E>
     //修饰符<泛型> 返回值类型  方法名（参数列表（使用泛型））
     ```

   - 定义含有泛型的接口

   - 接口第一种使用方式：定义接口的实现类，同时指定泛型

   - 接口第二种使用方式：接口用什么泛型，实现类就用什么泛型，创建对象的时候再确定具体类型

     ```java
     public class TestGeCom implements TestGe<String>{...}
     TestGeCom new1 = new TestGeCom();
     new1.method1("hahah");
     
     public class TestGenericImpl2<R> implements TestGe<R> {...}        
     TestGenericImpl2<Integer> new2 = new TestGenericImpl2<>();
     new2.method1(10);
     ```
   - 通配符<?>，代表任意的数据类型，不能创建对象使用，只能作为方法的参数使用。泛型的上限下限限定，？extends E，只能是E的子类或它本身，？super E，父类...
     


4. 数据结构

   - 栈，队列，数组，链表，红黑树

   - 数组：查询快，增删慢，地址连续，通过索引快速查找；数组长度固定，想增删必须创建新数组

   - 链表：查询慢，增删快。链表中的地址不连续，每次查询必须从头开始；链表结构，增删对整体结构无影响
   
     ![链表结构](D:\HH_STUDY-test\基础知识加强版\06集合\学习笔记.assets\链表结构.png)
     
   - 树：排序树、查找树与红黑树查询的速度非常快
   
     ![树](D:\HH_STUDY-test\基础知识加强版\06集合\学习笔记.assets\树.png)
   
5. l**ist集合**

   - **有序集合（存储于取出一致，有索引，允许存储重复的），有带索引的方法！**  
   - **操作索引的时候，一定要防止索引越界异常！**
   - ArrayList：数组实现，不是同步的，是多线程，查询快但是增删慢，每次增加都必须完成一次copy
   - LinkedList：链表实现，不同步，多线程，查询慢但是增删快。包含大量操作首位数据的方法
   - Vector：数组实现，单线程，同步的

6. **Set集合**

   - **无序集合（没有索引，不允许存储重复的），没有带索引的方法！**不能使用for遍历  

   - **HashSet：哈希表结构，查询快，不同步，无序集合。只能用迭代器和增强for遍历。注意存的和取得顺序可能不一致。**

   - 哈希值：地址的逻辑地址，是一个十进制的整数，由系统随机给出，哈希表：数组+链表/数组+红黑树（链表长度超过8位，**提高查询速度**）

   - 用HashSet存储自定义元素时，自定义类必须重写了hashcode和equals方法，才能保证自己集合中保存的元素唯一

   - LinkedHashSet：继承上面那个，区别是多了一条链表用来记录元素的存储顺序**，保证元素有序**，存入和取出的顺序一致

   - 可变参数:当参数列表数据类型已经确定，但是参数个数不确定，底层就是一个数组，根据传递参数个数不同，创建不同长度的数组，个数0-n。

   - 一个方法的参数列表只能有一个可变参数，且可变参数必须写在参数列表的末尾。

     ```java
     public static int add(int...arr){
       int sum = 0;
       for(int i:arr){
        return sum+=i;
        }
     }
     //终极写法
     public static int add(int...arr){}
     ```

7. Collections工具类

   - 用来对集合进行操作（就和arrays工具类操作数组一样）

     ```java
     Arraylist<String> list = new Arraylist<>();
     Collections.addAll(list,"a","b"."v");//添加
     
     //排序，默认升序。注意用排序方法时被排序的集合里面存储的元素必须实现重写了comparTo方法
     //自己(this)-参数，升序
     Collections.sort(list);
     //打乱
     Collections.suffle(list)
     ```
   - 用来对集合进行操作（就和arrays工具类操作数组一样）
   
8. Map集合

   - （与Collection集合完全不同）双列集合，一个元素包含key.value两个值，key不可重复，两者类型可以一致也可以不一致，后者可以重复，一一对应
   
   - HashMap<K,V>：不同步，速度快，无序
   
   - LinkedHashMap：**有序**
   
   - 常用方法：**put,添加，返回添加元素的值V；remove，删除，返回被删除元素的值V；get()，通过K来获取V；containsKey，包含返回true**
   
   - 遍历方法：
   
     1. keyset():把所有的key取出来存到set集合中，用迭代器或增强for来遍历，获取每一个key;用getkey()方法通过key获取value
   
     2. map.Entry<K,V>，创建结婚证；把entry对象取出来放在set中；遍历；entry.getkey（）获取value
   
   - HashMap存储自定义类型数据：必须重写HashCode和equlas方法
   
   - HashTable：不允许存储空，前面的都可以存空，同步的，单线程
   
9. debug

   - IDEA代码调试：打断点（直接在行号上面点击一下）
   - F7:一行一行的debug
   - F8:方法内部一行一行执行，调用嵌套方法的断点处不进入方法，直接调用其结果
   - F9:从一个断点位置直接调到下一个断点处
