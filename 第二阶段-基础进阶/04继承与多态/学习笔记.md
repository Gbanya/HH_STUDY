#### 继承与多态

1. 接口

   - ```java
     //创建一个接口 File->New->Interface
     public interface AD {
             //空方法
         public abstract void physicAttack();
         //默认方法
         public defalut void test(){
             //方法体
         }
     }
      
     //实现某个接口必须实现其中的所有抽象方法
     public class ADHero extends Hero implements AD{
      
         @Override
         public void physicAttack() {
             System.out.println("进行物理攻击");
         }
      
     }
     //实现多个接口
     public class ADAPHero extends Hero implements AD,AP{
       
         @Override
         public void magicAttack() {
             System.out.println("进行魔法攻击");
         }
       
         @Override
         public void physicAttack() {
             System.out.println("进行物理攻击");
       }
       
     }
     ```
     
   - 如果实现类没有覆盖重写接口中的所有**抽象方法**，那这个实现类必须是**抽象类**。

   - **接口的默认方法（java8以上）可以解决接口升级的问题**

   - 不能通过接口实现类的对象来调用接口当中的静态方法，应该通过接口

   - 接**口的私有方法解决代码重复问题，但是不能为实现类调用**

   - 接口当中可以定义常量，用完全大写字母，下划线分隔

     ```java
     public static final int NUM = 10;//前面三个关键字是固定的,可以省略
     ```

   - 接口之中的常量必须进行赋值。

   - **接口是不能有静态代码块或者构造方法的**

   - 如果实现的接口中有重复的抽象方法，只需要覆盖一次

   - **继承优先于接口实现**

   - 接口可以多继承与类不同

2. 抽象
   - 加上abstract关键字，去掉大括号，直接分号结束。抽象方法所在的类必须是抽象类，抽象类中可以有非抽象方法。

   - **不能直接new创建抽象类对象**

   - 必须用一个**子类来继承**抽象父类

   - 子类必须覆盖重写（实现）父类中的抽象方法

   - 创建**子类的对象**进行使用

   - ```java
     //抽象类
     public abstract class Animal{
         //抽象方法
         public abstract void eat();
     }
     
     ```

3. super关键字-用来访问父类内容

   - 在子类的成员方法中，访问父类的成员变量。

   - 在子类的成员方法中，访问父类的成员方法。

   - 在子类的构造方法中，访问父类的构造方法。


4. this关键字-用来访问本类内容

   ```java
   public zi(){
       this(123);//无参调有参构造函数
   }
   public zi(int n){
       
   }
   ```

5. 多态

   - ```java
      /*父类引用指向子类对象,格式
      * 父类名称 名称 = new 子类名称（）；
      * 接口名称 名称 = new 实现类名称（）；
      * */
      ```

   - **一个对象拥有多种形态，称之为多态。**

   - 访问成员变量的两种方式：

     - 直接通过对象名称访问成员变量，看等号左边是谁，优先用谁，没有则向上找。
     - 间接通过成员方法访问成员变量，看该方法属于谁，优先用谁，没有就向上找。（没有覆盖重写就是父类的，覆盖重写了就是子类的）

     ```java
     Fu obj = new Zi();
     System.out.println(obj.num);//用的是fu中的
     ```

   - 成员方法的访问规则：
     
     - 看new的是谁，就优先用谁，没有则向上找
     - 编译看左边，运行看右边
     
   - 向上转型（多态）一定是安全的，但是一旦向上转型为父类，就不能调用子类中特有的方法了。
     
   - 向下转型，从父类还原为子类类型。一定要先进行**类型判断**

     ```java
   Fu obj = new Zi();//向上转型
     Zi obj2 = (Fu) obj;
     ```
     
   - **如何才能知道一个父类的引用，本来是什么子类。**

     ```java
     //对象 instanceof 类名称
     Fu obj = new Zi();//向上转型
     
     if(obj instanceof Zi){
     	Zi obj2 = (Fu) obj;
     }
     ```

6. Final关键字

   - 最终不可改变的

   - 当**final**用来修饰一个**类**的时候，**不能**有任何的**子类**

     ```java
     public final class Myclass{
     	
     }//如果类是fianl的，其中所有的成员方法都不能被覆盖重写（因为没儿子)
     ```

   - 修饰一个方法，这个方法在子类中不能被覆盖重写。对于类和方法来说，final和abstract不能同时使用

     ```java
     public class Myclass{
         public final void method（）{
             //方法体;
         }
     }
     ```
     
   - **修饰局部变量：以此赋值，终身不变。对于基本类型来说，指数据不可变，对于引用类型来说，是指地址值不可变，但是其中的内容可变。**

   - 修饰成员变量，因为成员变量具备初始值，final之后必须手动赋值，就不是空了。类中所有的构造方法都必须保证对成员变量赋值。

7. 内部类

   - 成员内部类

     - 定义格式（一般使用$符号）

       ```java
       修饰符 class 外部类名称{
       	修饰符 class 内部类名称{
       	}
       }
       ```

     - 内用外，随意访问，外用内，一定得有内部类的对象

     - 调用方式：外部类名称.内部类名称 对象名 = new 外部类名称（）.new 内部类名称（）

       ```java
       //重名问题
       public class Outer{
       	int num = 10;//外部类的成员变量
       	public class Inner{
       		int num = 20;//内部类的成员变量
       		
       		public void methodInner(){
       			int num = 30;
       			sout(num);//30
       			sout(this.num);//20
       			sout(Outer.this.num);//10
       		}
       	}
       }
       ```

   - 局部内部类（包含**匿名内部类**）不能写修饰符

     - 定义在方法内部的类

     - 内部类想用外部变量的时候，外部变量得是final过的，才能复制。

     - 如果接口的实现了（或者是父类的子类）只需要使用一次，该类可以省略，使用内部类

       ```
       接口名称 对象名 = new 接口名称（）{
       	//覆盖重写所有的抽象方法
       }
       ```

     - **匿名内部类的注意事项**：

       1）在创建对象的时候只能使用唯一的一次，如果希望多次创建对象，用类

       2）匿名内部类是省略了类的名称，匿名对象是省略了对象名称，二者不是一回事儿

   - **类可以作为成员变量(比如String就是一个类)**

   - 接口作为成员变量


