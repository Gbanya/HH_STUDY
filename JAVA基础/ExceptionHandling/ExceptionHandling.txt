产生原因：
	*用户输入了非法数据
	*要打开的文件不存在了
	*网络通信时连接中断，或者JVM内存溢出

异常类型：
	*检查性异常：用户产生
	*运行时异常：编译时忽略
	*错误：如栈溢出
	
java异常类：
	*IOException类
	*RuntimeException类
	
异常方法：
	*getMessage()：返回异常信息
	*getCause()：返回异常原因
	*printStackTrace()：打印错误输出流
	*getStackTrace()：返回一个包含堆栈层次的数组
	*fillnStackTrace()：用当前的调用栈层次填充Throwable 对象栈层次，添加到栈层次任何先前信息中。

捕获异常：
	*
		try{
			...
		}catch(异常类型 异常的变量名){
			...
		}
		
多重捕获：
	*
		try{
		   ...
		}catch(异常类型1 异常的变量名1){
		  ...
		}catch(异常类型2 异常的变量名2){
		  ...
		}catch(异常类型2 异常的变量名2){
		 ..
		}
		
throws/throw:
	*如果一个方法没有捕获到一个检查性异常，那么该方法必须使用 throws 关键字来声明。
	*throws 关键字放在方法签名的尾部。
	*也可以使用 throw 关键字抛出一个异常，无论它是新实例化的还是刚捕获到的。
	*一个方法可以声明抛出多个异常，多个异常之间用逗号隔开。
	
finally：
	*finally 关键字用来创建在 try 代码块后面执行的代码块。
	*无论是否发生异常，finally 代码块中的代码总会被执行。
	*在 finally 代码块中，可以运行清理类型等收尾善后性质的语句。
	*finally 代码块出现在 catch 代码块最后
	*
		try{
		  ...
		}catch(异常类型1 异常的变量名1){
		  ...
		}catch(异常类型2 异常的变量名2){
		  ...
		}finally{
		  ...
		}
		
注意：
	*catch 不能独立于 try 存在。
	*在 try/catch 后面添加 finally 块并非强制性要求的。
	*try 代码后不能既没 catch 块也没 finally 块。
	**try, catch, finally 块之间不能添加任何代码。
	
自定义异常：
	*继承Throwable类
	*所有异常都必须是 Throwable 的子类。
	*如果希望写一个检查性异常类，则需要继承 Exception 类。
	*如果你想写一个运行时异常类，那么需要继承 RuntimeException 类。
	*
		class MyException extends Exception{
		}