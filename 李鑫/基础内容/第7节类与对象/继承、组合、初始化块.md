# 继承、组合、初始化块

## 继承

为了保证父类具有良好的封装性，不会被子类随意改变，设计父类通常应该遵循如下规则：

* 尽量隐藏父类的内部数据。尽量把父类的所有成员变量都设置成private访问类型，不要让子类直接访问父类的成员变量。

* 不要让子类可以随意访问、修改父类的方法。**父类中那些仅为辅助其他的工具方法，应该使用private访问控制符修饰，让子类无法访问该方法；如果父类中的方法需要被外部类调用，则必须以public修饰，但又不希望子类重写该方法，可以使用final修饰符（该修饰符后面会有更详细的介绍）来修饰该方法；如果希望父类的某个方法被子类重写，但不希望被其他类自由访问，则可以使用protected来修饰该方法。**

```Java
class Base {
    public Base() {
        test();
    }
    public void test() {
        System.out.println("将被子类重写的方法");
    }
}

public class Sub extends Base {
    private String name;
    public void test() {
        System.out.println("子类重写父类的方法" + "其name字符串长度" + name.length());
    }
    public static void main(String[] args) {
        // 下面的代码会引起空指针
        Sub s = new Sub();
    }
}
```

当系统试图创建Sub对象时，同样会先执行其父类构造器，如果父类构造器调用了被其子类重写的方法，则变成调用被子类重写后的方法。当创建Sub对象时，会先执行Base类中的Base构造器，而Base构造器中调用了test()方法——并不是调用父类的test()方法，而是调用子类的test()方法，此时Sub对象的name实例变量是null，因此将引发空指针异常。

如果想把某些类设置成最终类，即不能被当成父类，则可以使用final修饰这个类，例如JDK提供的java.lang.String类和java.lang.System类。除此之外，使用private修饰这个类的所有构造器，从而保证子类无法调用该类的构造器，也就无法继承该类。对于把所有的构造器都使用private修饰的父类而言，可另外提供一个静态方法，用于创建该类的实例。

## 组合

```Java
class Animal {
    private void beat() {
        System.out.println("心脏跳动");
    }
    public void breathe() {
        beat();
        System.out.println("吸一口气，吐一口气，呼吸中...");
    }
}

class Bird extends Animal {
    public void fly() {
        System.out.println("我在飞...");
    }
}

class Wolf extends Animal {
    public void run() {
        System.out.println("我在跑...");
    }
}

public class InheriteTest {
    public static void main(String[] args) {
        Bird b = new Bird();
        b.breathe();
        b.fly();

        Wolf w = new Wolf();
        w.breathe();
        w.run();
    }
}
```

上面的使用继承方式的代码，可以由组合的方式改写：

```Java
class Animal {
    private void beat() {
        System.out.println("心脏跳动");
    }
    public void breathe() {
        beat();
        System.out.println("吸一口气，吐一口气，呼吸中...");
    }
}

class Bird extends Animal {
    // 将原来的父类组合到原来的子类，作为子类的一个组合部分
    private Animal a;
    public Bird(Animal a) {
        this.a = a;
    }
    // 重新定义一个自己的breathe方法
    public void breathe() {
        // 直接复用Animal的breathe方法
        a.breathe();
    }
    public void fly() {
        System.out.println("我在飞...");
    }
}

class Wolf extends Animal {
    // 将原来的父类组合到原来的子类，作为子类的一个组合部分
    private Animal a;
    public Wolf(Animal a) {
        this.a = a;
    }
    // 重新定义一个自己的breathe方法
    public void breathe() {
        // 直接复用Animal的breathe方法
        a.breathe();
    }
    public void run() {
        System.out.println("我在跑...");
    }
}

public class InheriteTest {
    public static void main(String[] args) {
        // 此时需要显示创建被组合的对象
        Animal a1 = new Animal();
        Bird b = new Bird(a1);
        b.breathe();
        b.fly();
        // 此时需要显示创建被组合的对象
        Animal a2 = new Animal();
        Wolf w = new Wolf(a2);
        w.breathe();
        w.run();
    }
}
```

## 初始化块

Java使用构造器来对单个对象进行初始化操作，使用构造器先完成整个Java对象的状态初始化，然后将Java对象返回给程序，从而让该Java对象的信息更加完整。与构造器作用非常类似的是初始化块，它也可以对Java对象进行初始化操作。

初始化块是Java类里可出现的第4种成员（前面依次有成员变量、方法和构造器），一个类里可以有多个初始化块，相同类型的初始化块之间有顺序：前面定义的初始化块先执行，后面定义的初始化块后执行。

```Java
[修饰符] {
    /*...*/
}
```

**初始化块的修饰符只能是static**，使用static修饰的初始化块被称为类初始化块（静态初始化块），没有static修饰的初始化块被称为实例初始化块（非静态初始化块）。初始化块里的代码可以包含任何可执行性语句，包括定义局部变量、调用其他对象的方法，以及使用分支、循环语句等。

```Java
public class Person
{
    // 定义一个实例初始化块
    {
        int a = 6;
        if (a > 4) {
            System.out.println("Person实例化块：局部变量a的值大于4");
        }
        System.out.println("Person实例化块");
    }
    // 定义第二个实例初始化块
    {
        System.out.println("Person的第二个实例化块");

    }
    public Person() {
        System.out.println("Person类的无参构造器");
    }
    public static void main(String[] args) {
        new Person();
    }
}
```

输出如下：

```TXT
Person实例化块：局部变量a的值大于4
Person实例化块
Person的第二个实例化块
Person类的无参构造器
```

从运行结果可以看出，当创建Java对象时，系统总是先调用该类里定义的实例初始化块，如果一个类里定义了2个实例初始化块，则前面定义的实例初始化块先执行，后面定义的实例初始化块后执行。初始化块虽然也是Java类的一种成员，但它没有名字，也就没有标识，因此无法通过类、对象来调用初始化块。实例初始化块只在创建Java对象时隐式执行，而且在构造器执行之前自动执行。类初始化则在类初始化阶段自动执行。

**实例初始化块的基本用法，如果有一段初始化处理代码对所有对象完全相同，且无须接收任何参数，就可以把这段初始化处理代码提取到实例初始化块中**

类初始化块是类相关的，系统将在类初始化阶段执行类初始化块，而不是在创建对象时才执行。因此类初始化块总是比实例初始化块先执行。

```Java
class Root {
    static {
        System.out.println("Root的类初始化块");
    }
    {
        System.out.println("Root的实例初始化块");

    }
    public Root() {
        System.out.println("Root的无参构造器");
    }
}

class Mid extends Root {
    static {
        System.out.println("Mid的类初始化块");
    }
    {
        System.out.println("Mid的实例初始化块");

    }
    public Mid() {
        System.out.println("Mid的无参构造器");
    }
    public Mid(String msg) {
        this();  // 调用同一类的重载构造器
        System.out.println("Mid带参数的构造器，其参数值：" + msg);
    }
}

class Leaf extends Mid {
    static {
        System.out.println("Leaf的类初始化块");
    }
    {
        System.out.println("Leaf的实例初始化块");

    }
    public Leaf() {
        super("Hello");  // 调用父类的参数构造器
        System.out.println("执行Leaf的构造器");
    }
}

public class Test {
    public static void main(String[] args) {
        new Leaf();
        new Leaf();
    }
}
```

输出如下：

```TXT
// 第一次新建一个Leaf的输出
Root的类初始化块
Mid的类初始化块
Leaf的类初始化块
Root的实例初始化块
Root的无参构造器
Mid的实例初始化块
Mid的无参构造器
Mid带参数的构造器，其参数值：Hello
Leaf的实例初始化块
执行Leaf的构造器

// 第二次新建一个Leaf的输出
Root的实例初始化块
Root的无参构造器
Mid的实例初始化块
Mid的无参构造器
Mid带参数的构造器，其参数值：Hello
Leaf的实例初始化块
执行Leaf的构造器
```

从输出可以看出，第一次创建一个Leaf对象时，因为系统中还不存在Leaf类，因此需要先加载并初始化Leaf类，初始化Leaf类时会先执行其顶层父类的类初始化块，再执行其直接父类的类初始化块，最后才执行Leaf本身的类初始化块。
一旦Leaf类初始化成功后，Leaf类在该虚拟机里将一直存在，因此当第二次创建Leaf实例时无须再次对Leaf类进行初始化。实例初始化块和构造器的执行顺序与前面介绍的一致，每次创建一个Leaf对象时，都需要先执行最顶层父类的实例初始化块、构造器，然后执行其父类的实例初始化块、构造器……最后才执行Leaf类的实例初始化块和构造器。

**类初始化块和声明类变量时所指定的初始值都是该类的初始化代码，它们的执行顺序与源程序中的排列顺序相同。**

```Java
public class StaticInitTest {
    // 先执行类初始化块将变量a赋值为6
    static {
        a = 6;
    }
    // 再将类变量a赋值为9
    static int a = 9;
    public static void main(String[] args) {
        // 下面输出为：9
        // 调换上面赋值语句的顺序，将可以看到程序输出6，这是由于类初始化块中代码再次将a的值设为6。
        System.out.println(StaticInitTest.a);
    }
}
```
