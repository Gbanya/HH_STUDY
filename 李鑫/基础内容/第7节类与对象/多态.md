# 多态 #  

Java引用变量有两个类型：一个是**编译时类型**，一个是**运行时类型**。编译时类型由声明该变量时使用的类型决定，运行时类型由实际赋给该变量的对象决定。如果编译时类型和运行时类型不一致，就可能出现所谓的**多态（Polymorphism）**。  

## 多态性 ##  

```Java
class BaseClass {
    public int book = 6;

    public void base() {
        System.out.println("父类的普通方法");
    }

    public void test() {
        System.out.println("父类被覆盖的方法");
    }
}

public class SubClass extends BaseClass {
    // 重新定义一个book实例变量来隐藏父类的book实例变量
    public String book = "cdut";

    public void test() {
        System.out.println("子类覆盖父类的方法");
    }

    public void sub() {
        System.out.println("子类的普通方法");
    }

    public static void main(String[] args) {
        // 编译时类型与运行时类型不一致，多态发生
        BaseClass polymophicBc = new SubClass();
        
        // 下面的输出为6，表明访问的是父类的实例变量
        System.out.println(polymophicBc.book);

        // 下面调用将执行从父类继承到的base()方法
        polymophicBc.base();

        // 下面调用将执行当前类的test()方法
        polymophicBc.test();

        // 因为polymophicBc的编译类型是BaseClass
        // 它没有提供sub()方法，所以下面的代码编译时会出错
        // polymophicBc.sub();
    }
}
```  

得到下面的输出：

```TXT
6
父类的普通方法
子类覆盖父类的方法
```  

**子类其实是一种特殊的父类**，因此Java允许把一个子类对象直接赋给一个父类引用变量，无须任何类型转换，或者被称为向上转型（upcasting），向上转型由系统自动完成。

当把一个子类对象直接赋给父类引用变量时，例如上面的BaseClass ploymophicBc=newSubClass();，这个ploymophicBc引用变量的编译时类型是BaseClass，而运行时类型是SubClass，当运行时调用该引用变量的方法时，**其方法行为总是表现出子类方法的行为特征，而不是父类方法的行为特征**，这就可能出现：相同类型的变量、调用同一个方法时呈现出多种不同的行为特征，这就是多态。

**与方法不同的是，对象的实例变量则不具备多态性**。

> **注意：** 引用变量在编译阶段只能调用其编译时类型所具有的方法，但运行时则执行它运行时类型所具有的方法。因此，编写Java代码时，引用变量只能调用声明该变量时所用类里包含的方法。例如，通过Object p=new Person()代码定义一个变量p，则这个p只能调用Object类的方法，而不能调用Person类里定义的方法。因此上面代码中ploymophicBc实例无法调用sub()方法。  

## 引用变量的强制类型转换 ##  

编写Java程序时，引用变量只能调用它编译时类型的方法，而不能调用它运行时类型的方法，即使它实际所引用的对象确实包含该方法。如果需要让这个引用变量调用它运行时类型的方法，则必须把它**强制类型转换成运行时类型**，强制类型转换需要借助于类型转换运算符。

```Java
(type)variable
```

当进行强制类型转换时需要注意：

* 基本类型之间的转换只能在数值类型之间进行，这里所说的数值类型包括**整数型、字符型和浮点型**。但数值类型和布尔类型之间不能进行类型转换。

* 引用类型之间的转换只能在具有继承关系的两个类型之间进行，如果是两个没有任何继承关系的类型，则无法进行类型转换，否则编译时就会出现错误。**如果试图把一个父类实例转换成子类类型，则这个对象必须实际上是子类实例才行（即编译时类型为父类类型，而运行时类型是子类类型）**，否则将在运行时引发ClassCastException异常。

## instanceof运算符 ##  

instanceof运算符的前一个操作数通常是一个引用类型变量，后一个操作数通常是一个类（也可以是接口，可以把接口理解成一种特殊的类），它用于判断前面的对象是否是后面的类，或者其子类、实现类的实例。如果是，则返回true，否则返回false。

在使用instanceof运算符时需要注意：instanceof运算符前面操作数的编译时类型要么与后面的类相同，要么与后面的类具有父子继承关系，否则会引起编译错误。

```Java
public class InstanceofTest {
    public static void main(String[] args) {
        // 声明hello时时Object类，即编译类型为Object
        // 但是其运行时类型为String
        Object hello = "Hello";

        // Object是所有类的父类，因此与String类存在继承关系，返回true
        System.out.println("字符串是否是Object类的实例：" + (hello instanceof Object));
        System.out.println("字符串是否是String类的实例：" + (hello instanceof String));

        // Math类与Object类存在继承关系，因此可以进行instanceof计算，返回false
        System.out.println("字符串是否是Math类的实例：" + (hello instanceof Math));

        // String类实现了Comparable接口，返回true
        System.out.println("字符串是否是Comparable接口的实例：" + (hello instanceof Comparable));

        // String类与Math类没有继承关系，返回false
        String a = "Hello";
        System.out.println("字符串是否是Math类的实例：" + (a instanceof Math));
    }
}
```  
