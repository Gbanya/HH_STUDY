# 类与对象  

**Java是面向对象的程序设计语言，类是面向对象的重要内容，可以把类当成一种自定义类型，可以使用类来定义变量，这种类型的变量统称为引用变量。也就是说，所有类是引用类型。**  

## 类  

> **类（class）** 是某一批对象的抽象；**对象（object）** 是一个具体存在的实体。  

定义类的简单语法如下所示：

```Java
[修饰符] class 类名
{
    /*零个或多个构造器定义*/
    /*零个或多个成员变量*/
    /*零个或多个方法*/
}
```

上面的语法格式中，修饰符可以是public，final，abstract，也可以忽略不写，类名只要满足标识符的合法性就可以了。

对一个类定义时，一般包含三种成员：**构造器、成员变量、方法**。成员变量用于定义该类或该类的实例所包含的状态数据，方法则用于定义该类或该类的实例的行为特征或者功能实现。构造器用于构造该类的实例，Java语言通过new关键字来调用构造器，从而返回该类的实例。类里各成员之间的定义顺序没有任何影响，各成员之间可以相互调用。

> **注意：** static修饰的成员不能访问没有static修饰的成员！  

成员变量、方法、构造器的定义的语法格式如下：  

```Java
[修饰符] 类型 成员变量名 [= 默认值];

[修饰符] 方法返回值类型 方法名(形参列表)
{
    /*...*/
}

[修饰符] 构造器名(形参列表)
{
    /*...*/
}
```

* 成员变量修饰符：可以省略，也可以是public、protected、private、static、final，其中public、protected、private三个最多只能出现其中之一，可以与static、final组合起来修饰成员变量。

* 方法修饰符：可以省略，也可以是public、protected、private、static、final、abstract，其中public、protected、private三个最多只能出现其中之一；abstract和final最多只能出现其中之一，它们可以与static组合起来修饰方法。

* 构造器修饰符：可以省略，也可以是public、protected、private其中之一。

> **注意：** 构造器既不能定义返回值类型，也不能使用void声明构造器。如果为构造器定义了返回值类型，或使用void声明构造器没有返回值，编译时不会出错，但Java会把这个所谓的构造器当成方法来处理——它就不再是构造器。  

## 对象  

创建对象的根本途径是构造器，通过new关键字来调用某个类的构造器即可创建这个类的实例。  

```Java
// 使用Person类定义并初始化一个Person类型的变量
Person p = new Person();
```

### this  

Java提供了一个this关键字，this关键字总是指向调用该方法的对象。this作为对象的默认引用有两种情形：

* 构造器中引用该构造器正在初始化的对象。

* 在方法中引用调用该方法的对象。

this关键字最大的作用就是让类中一个方法，访问该类里的另一个方法或实例变量。  
假设定义了一个Dog类，这个Dog对象的run()方法需要调用它的jump()方法，代码如下：

```Java
public class Dog
{
    // 定义一个jump方法
    public void jump()
    {
        System.out.println("正在执行jump方法");
    }

    // 定义一个run方法
    public void run()
    {
        Dog d = new Dog();
        d.jump();
        System.out.println("正在执行run方法");
    }
}
```

下面再提供一个程序来创建Dog对象，并调用该对象的run()方法。  

```Java
public class DogTest
{
    public static void main(String[] args)
    {
        Dog dog = new Dog();
        dog.run();
    }
}
```

在上面的程序中，一共产生了两个Dog对象，在Dog类的run()方法中，程序创建了一个Dog对象，并使用名为d的引用变量来指向该Dog对象；在DogTest的main()方法中，程序再次创建了一个Dog对象，并使用名为dog的引用变量来指向该Dog对象。首先调用run方法必须创建一个Dog对象，因此在run方法中调用jump方法不需要再创建一个新的Dog对象，其run方法修改如下：

```Java
public void run()
{
    this.jump();
    System.out.println("正在执行run方法");
}
```  

Java允许对象的一个成员直接调用另一个成员，可以省略this前缀。也就是说，将上面的run()方法改为如下形式也完全正确。

```Java
public void run()
{
    jump();
    System.out.println("正在执行run方法");
}
```  

> **注意：** 如果在static修饰的方法中使用this关键字，则这个关键字就无法指向合适的对象。所以，static修饰的方法中不能使用this引用。由于static修饰的方法不能使用this引用，所以static修饰的方法不能访问不使用static修饰的普通成员，因此Java语法规定：静态成员不能直接访问非静态成员。

当this作为对象的默认引用使用时，程序可以像访问普通引用变量一样来访问这个this引用，甚至可以把this当成普通方法的返回值。

```Java
public class ReturnThis
{
    public int age;
    public ReturnThis grow()
    {
        age++;
        return this;
    }
    public static void main(String[] args) {
        ReturnThis rt = new ReturnThis();
        rt.grow().grow().grow();
        System.out.println("rt的age成员变量值是：" + rt.age);
        // output: age = 3
    }
}
```  

## 成员变量与局部变量  

成员变量指的是在类里定义的变量；局部变量指的是在方法里定义的变量。

类变量与实例变量统称为成员变量。当使用该类的实例访问类变量时，如果修改了类变量的值，由于这个类变量并不属于这个实例，而是它对应的类。因此，修改的依然是类的类变量，与通过该类来修改类变量的结果完全相同，这会导致该类的其他实例来访问这个类变量时也将获得这个被修改过的值。

```Java
public class Person
{
    public String name;  // 实例变量
    public static int eyeNum;  // 类变量

    public static void main(String[] args) {
        System.out.println("Person类的eyeNum类变量值：" + Person.eyeNum);  // output Person.eyeNum = 0

        Person p = new Person();
        p.name = "小李";
        p.eyeNum = 2;

        System.out.println("对象p的name变量值为：" + p.name + "，对象p的eyeNum变量值为：" + p.eyeNum);  // output 小李 2
        System.out.println("Person的eyeNum变量值：" + Person.eyeNum);  // output 2

        Person p2 = new Person();
        System.out.println("对象p2的eyeNum变量值为：" + p2.eyeNum);  // output 2

    }
}
```

当代码第一次使用某个类时，系统通常会在这个时候加载这个类，并初始化这个类。在类的准备阶段，系统会为该类的**类变量**分配内存空间，并指定默认初始值。

局部变量定义后，必须经过**显式初始化**后才能使用，系统不会为局部变量执行初始化。这意味着定义局部变量后，系统并未为这个变量分配内存空间，直到等到程序为这个变量赋初始值时，系统才会为局部变量分配内存，并将初始值保存到这块内存中。  

## 隐藏和封装

**封装（Encapsulation）** 指的是将对象的状态信息隐藏在对象内部，不允许外部程序直接访问对象内部信息，而是通过该类所提供的方法来实现对内部信息的操作和访问。其目的如下：

* 隐藏类的实现细节

* 让使用者只能通过事先预定的方法来访问数据，从而可以在该方法里加入控制逻辑，限制对成员变量的不合理访问。

* 可进行数据检查，从而有利于保证对象信息的完整性。

* 便于修改，提高代码的可维护性。

封装使用Java提供的**访问控制符**来实现，主要从以下两个方面考虑：

1. 将对象的成员变量和实现细节隐藏起来，不允许外部直接访问。

2. 把方法暴露出来，让方法来控制对这些成员变量进行安全的访问和操作。  

### 访问控制符  

Java提供了3个访问控制符：private、protected和public，分别代表了3个访问控制级别，另外还有一个不加任何访问控制符的访问控制级别，提供了4个访问控制级别。访问级别由小到大：**private->default->protected->public**。

* private（**当前类**访问权限）：如果类里的一个成员（包括成员变量、方法和构造器等）使用private访问控制符来修饰，则这个成员只能在当前类的内部被访问。很显然，这个访问控制符用于修饰成员变量最合适，使用它来修饰成员变量就可以把成员变量隐藏在该类的内部。

* default（**包**访问权限）：如果类里的一个成员（包括成员变量、方法和构造器等）或者一个外部类不使用任何访问控制符修饰，就称它是包访问权限的，default访问控制的成员或外部类可以被相同包下的其他类访问。

* protected（**子类**访问权限）：如果一个成员（包括成员变量、方法和构造器等）使用protected访问控制符修饰，那么这个成员既可以被同一个包中的其他类访问，也可以被不同包中的子类访问。在通常情况下，如果使用protected来修饰一个方法，**通常是希望其子类来重写这个方法**。

* public（**公共**访问权限）：这是一个最宽松的访问控制级别，如果一个成员（包括成员变量、方法和构造器等）或者一个外部类使用public访问控制符修饰，那么这个成员或外部类就可以被所有类访问，不管访问类和被访问类是否处于同一个包中，是否具有父子继承关系。

|   | private | default | protected | public |
| :-: | :-: |:-: |:-: |:-: |
| 同一个类中| ✔ | ✔ |✔ |✔ |
| 同一个包中|  | ✔ |✔ |✔ |
| 子类中|  |  |✔ |✔ |
| 全局范围内|  |  | |✔ |  


> **注意：** 如果一个Java源文件里定义的所有类都没有使用public修饰，则这个Java源文件的文件名可以是一切合法的文件名；但如果一个Java源文件里定义了一个public修饰的类，则这个源文件的文件名必须与public修饰的类的类名相同。

## package  

Java引入了包（package）机制，提供了类的多层命名空间，用于解决类的命名冲突、类文件管理等问题。

```Java
package packagename;
```

> **注意：** 把生成的class文件放在某个目录下，这个目录名就成了这个类的包名。这是一个错误的看法，不是有了目录结构，就等于有了包名。为Java类添加包必须在Java源文件中通过package语句指定，单靠目录名是没法指定的。Java的包机制需要两个方面保证：① 源文件里使用package语句指定包名；② class文件必须放在对应的路径下。

为了简化编程，Java引入了import关键字，import可以向某个Java文件中导入指定包层次下某个类或全部类，import语句应该出现在package语句（如果有的话）之后、类定义之前。一个Java源文件只能包含一个package语句，但可以包含多个import语句，多个import语句用于导入多个包层次下的类。

```Java
import package.subpackage...ClassName;  // 某一个类
import package.subpackage...*;  // 包下的全部类
```

> **注意：** Java默认为所有源文件导入java.lang包下的所有类，因此前面在Java程序中使用String、System类时都无须使用import语句来导入这些类。但对于前面介绍数组时提到的Arrays类，其位于java.util包下，则必须使用import语句来导入该类。

### import static

**静态导入**用于导入指定类的某个静态成员变量、方法或全部的静态成员变量、方法。

```Java
 // 导入指定类的单个静态成员变量、方法
 import static package.subpackage...ClassName.filedName | methodName;

 // 导入指定类的全部静态成员变量、方法
 import static package.subpackage...ClassName.*;
```

## 构造器  

当程序员调用构造器时，系统会先为该对象分配内存空间，并为这个对象执行默认初始化，这个对象已经产生了——这些操作在构造器执行之前就都完成了。也就是说，**当系统开始执行构造器的执行体之前，系统已经创建了一个对象**，只是这个对象还不能被外部程序访问，只能在该构造器中通过this来引用。当构造器的执行体执行结束后，这个对象作为构造器的返回值被返回，通常还会赋给另一个引用类型的变量，从而让外部程序可以访问该对象。

### 构造器重载

**同一个类里具有多个构造器，多个构造器的形参列表不同，即被称为构造器重载。**

当构造器B完全包含了构造器A，则可在方法B中调用方法A。但是构造器无法被直接调用，构造器必须使用new关键字来调用，但是这样会导致系统重新新建一个对象，因此**可以使用this关键字来调用相应的构造器**。

```Java
public class Apple {
    public String name;
    public String color;
    public double weight;

    public Apple() {};

    public Apple(String name, String color) {
        this.name = name;
        this.color = color;
    }

    public Apple(String name, String color, double weight) {
        // 通过this调用另一个重载的构造器的初始化代码
        this(name, color);
        // 下面这个this引用该构造器正在初始化的Java对象
        this.weight = weight;
    }
}
```

**使用this调用另一个重载的构造器只能在构造器中使用，而且必须作为构造器执行体的第一条语句**。使用this调用重载的构造器时，系统会根据this后括号里的实参来调用形参列表与之对应的构造器。

## 继承

Java的继承通过**extends**关键字来实现，实现继承的类被称为**子类**，被继承的类被称为**父类**，有的也称其为**基类**、**超类**。父类和子类的关系，是一种**一般和特殊**的关系。语法格式如下：

```Java
修饰符 class SubClass extends SuperClass {
    /*...*/
}
```  
> **注意：** 子类只能从被扩展的父类获得成员变量、方法和内部类（包括内部接口、枚举），不能获得构造器和初始化块。且每个类最多只有一个直接父类。

如果定义一个Java类时并未显式指定这个类的直接父类，则这个类默认扩展**java.lang.Object类**。因此，java.lang.Object类是所有类的父类，要么是其直接父类，要么是其间接父类。因此所有的Java对象都可调用java.lang.Object类所定义的实例方法。

**从子类角度来看，子类扩展（extends）了父类；但从父类的角度来看，父类派生（derive）出了子类**。也就是说，扩展和派生所描述的是同一个动作，只是观察角度不同而已。

### 重写父类的方法

子类扩展了父类，子类是一个特殊的父类。大部分时候，子类总是以父类为基础，额外增加新的成员变量和方法。但有一种情况例外：**子类需要重写父类的方法**。

例如鸟类都包含了飞翔方法，其中鸵鸟是一种特殊的鸟类，因此鸵鸟应该是鸟的子类，因此它也将从鸟类获得飞翔方法，但这个飞翔方法明显不适合鸵鸟，为此，鸵鸟需要重写（Override）鸟类飞翔这个方法。

```Java
public class Bird {
    public void fly() {
        System.out.println("我在天空自由地飞翔...");
    }
}
```

```Java
public class Ostrich extends Bird {
    public void fly() {
        System.out.println("我只能在地上奔跑...");
    }

    public static void main(String[] args) {
        Ostrish os = new Ostrish();
        os.fly();
        // output: 我只能在地上奔跑...
    }
}
```

> **注意：方法的重写要遵循“两同两小一大”规则，“两同”即方法名相同、形参列表相同；“两小”指的是子类方法返回值类型应比父类方法返回值类型更小或相等，子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等；“一大”指的是子类方法的访问权限应比父类方法的访问权限更大或相等。尤其需要指出的是，覆盖方法和被覆盖方法要么都是类方法，要么都是实例方法，不能一个是类方法，一个是实例方法。**

例如，如下代码将会引发编译错误。

```Java
class Baseclass {
    public static void test() {...}
}

class SubClass extends BaseClass {
    public void test() {...}
}
```

当子类覆盖了父类方法后，**子类的对象**将无法访问父类中被覆盖的方法，但可以在**子类方法**中调用父类中被覆盖的方法。如果需要在子类方法中调用父类中被覆盖的方法，则可以使用**super**（被覆盖的是实例方法）或者**父类类名**（被覆盖的是类方法）作为调用者来调用父类中被覆盖的方法。如果父类方法具有private访问权限，则该方法对其子类是隐藏的，因此其子类无法访问该方法，也就是无法重写该方法。如果子类中定义了一个与父类private方法具有相同的方法名、相同的形参列表、相同的返回值类型的方法，依然不是重写，只是在子类中重新定义了一个新方法。

### super限定

super是Java提供的一个关键字，super用于限定该对象调用它从父类继承得到的实例变量或方法。正如this不能出现在static修饰的方法中一样，super也不能出现在static修饰的方法中。

如果在构造器中使用super，则super用于限定该构造器初始化的是该对象从父类继承得到的实例变量，而不是该类自己定义的实例变量。

如果子类定义了和父类同名的实例变量，则会发生子类实例变量隐藏父类实例变量的情形。在正常情况下，子类里定义的方法直接访问该实例变量默认会访问到子类中定义的实例变量，无法访问到父类中被隐藏的实例变量。

```Java
class BaseClass {
    public int a = 5;
}

public class SubClass extends BaseClass {
    public int a = 7;

    public void accessOwner() {
        System.out.println(a);
    }

    public void accessBase() {
        // 通过super来限定访问从父类继承得到的a实例变量
        System.out.println(super.a);
    }

    public static void main(String[] args) {
        SubClass sc = new SubClass();
        sc.accessOwner();  // output: 7
        sc.accessBase();  // output: 5
    }
}
```

如果被覆盖的是类变量，在子类的方法中则可以通过父类名作为调用者来访问被覆盖的类变量。

> **提示：** 当程序创建一个子类对象时，系统不仅会为该类中定义的实例变量分配内存，也会为它从父类继承得到的所有实例变量分配内存，即使子类定义了与父类中同名的实例变量。也就是说，当系统创建一个Java对象时，如果该Java类有两个父类（一个直接父类A，一个间接父类B），假设A类中定义了2个实例变量，B类中定义了3个实例变量，当前类中定义了2个实例变量，那么这个Java对象将会保存2+3+2个实例变量。

```Java
class Parent {
    public String tag = "成都理工大学";
}

class Derived extends Parent {
    // 定义一个私有实例变量tag来隐藏父类的tag实例变量
    private String tag = "cdut";
}

public class HideTest {
    public static void main(String[] args) {
        Derived v = new Derived();
        // 程序不可访问d的私有变量tag，所以下面语句将引起编译错误
        // System.out.println(d.tag);
        // 将d变量显示地向上转型为Parent后，即可访问tag实例变量
        System.out.println(((Parent) d).tag);
        // output: 成都理工大学
    }
}
```

### 调用父类构造器

子类不会获得父类的构造器，但子类构造器里可以调用父类构造器的初始化代码。在一个构造器中调用另一个重载的构造器使用this调用来完成，在子类构造器中调用父类构造器使用super调用来完成。

```Java
class Base {
    public double size;
    public String name;
    public Base(double size, String name) {
        this.size = size;
        this.name = name;
    }
}

public class Sub extends Base {
    public String color;
    public Sub(double size, String name, String color) {
        // 通过super调用父类构造器
        super(size, name);
        this.color = color;
    }

    public static void main(String[] args) {
        Sub s = new Sub(5.6, "测试对象", "红色");
        System.out.println(s.size + "--" + s.name + "--" + s.color);
        // output:Sub对象的三个实例变量
    }
}
```

不管是否使用super调用来执行父类构造器的初始化代码，子类构造器总会调用父类构造器一次。子类构造器调用父类构造器分如下几种情况。

* 子类构造器执行体的第一行使用super显式调用父类构造器，系统将根据super调用里传入的实参列表调用父类对应的构造器。

* 子类构造器执行体的第一行代码使用this显式调用本类中重载的构造器，系统将根据this调用里传入的实参列表调用本类中的另一个构造器。执行本类中另一个构造器时也会先调用父类构造器。

* 子类构造器执行体中既没有super调用，也没有this调用，系统将会在执行子类构造器之前，隐式调用父类无参数的构造器。

不管上面哪种情况，当调用子类构造器来初始化子类对象时，**父类构造器总会在子类构造器之前执行**；不仅如此，执行父类构造器时，系统会再次上溯执行其父类构造器……依此类推，创建任何Java对象，最先执行的总是java.lang.Object类的构造器。

```Java

class Creature {
    public Creature() {
        System.out.println("Creature 无参数的构造器");
    }
}

class Animal extends Creature {
    public Animal(String name) {
        System.out.println("Animal带一个参数的构造器，" + "该动物的name为：" + name);
    }

    public Animal(String name, int age) {
        this(name);
        System.out.println("Animal带两个参数的构造器，" + "其age为：" + age);
    }
}

public class Wolf extends Animal {
    public Wolf() {
        // 显示调用父类的有两个参数的构造器
        super("灰太狼", 3);
        System.out.println("Wolf无参数的构造器");
    }

    public static void main(String[] args) {
        new Wolf();
    }
}
```

运行结果如下：

```TXT
Creature 无参数的构造器
Animal带一个参数的构造器，该动物的name为：灰太狼
Animal带两个参数的构造器，其age为：3
Wolf无参数的构造器
```

