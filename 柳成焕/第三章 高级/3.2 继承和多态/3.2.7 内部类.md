### 3.2.7 内部类

如果一个事物的内部包含另一个事物，那么这就是一个类内部包含另一个类。
 例如：身体和心脏、汽车和发动机
 
 内部类的分类：
 1.成员内部类
 2.局部内部类（匿名内部类）
 

#### 一、成员内部类的定义及使用

成员内部类的定义格式：
   *修饰符 class* *外部类名称{
\*     *修饰符 class* *内部类名称{
       //...
     }
     //...
   }
\* 
 注意：内用外，随意访问；外用内，一定需要借助内部类对象。
 
 内部类的使用：
 1、间接方式：在外部类的方法当中，使用内部类，然后main只是调用外部类的方法。
 2、直接方式：*【外部类名称**.**内部类名称* *对象名 = new* *外部类名称().new* *内部类名称();**】*

```
//1.在外部类的方法当中，使用内部类，然后main只是调用外部类的方法。
//外部类方法
/*public void methodBody(){
    System.out.println("外部类的方法执行！");
    new Body.Heart().beat();
}*/
Body body = new Body();
body.methodBody();

//2.直接方式：【外部类名称.内部类名称 对象名 = new 外部类名称.new 内部类名称();】
Body.Heart obj=new Body().new Heart();
obj.beat();
```

 

#### 二、成员内部类的同名变量访问

如果出现了重名现象，那么格式是：外部类名称.this.外部类成员变量

```
public class Outer {
    int num = 10;
    public class Inner {
        int num = 20;

        public void methodInner() {
            int num = 30;
            System.out.println("局部变量：" + num);  //局部变量
            System.out.println("内部类成员变量：" + this.num);//内部类成员变量
            System.out.println("外部类成员变量：" + Outer.this.num);//外部类成员变量
        }
    }
}
```

 

#### 三、局部内部类的定义及使用

如果一个类是定义在一个方法内部的，那么这就是一个局部内部类。
 “局部”：只有当前所属的方法才能使用它，出了这个方法就不能使用了。*
\*   *修饰符 class* *外部类名称{
\*     *修饰符* *返回值类型* *方法名称（参数列表）{
       class* *局部类名称{
         //...
       }
     }
   }*

 

#### 四、类的权限修饰符的使用

小结一下类的权限修饰符：
 *public > protected > (default) > private*
 定义一个类的时候，权限修饰符规则：
 1.外部类：*public / (default)*
 2.成员内部类：*public/protected/(default)/private*
 3.局部内部类：*什么都不能写*

 

#### 五、局部内部类的final问题

局部内部类如果希望访问所在方法的局部变量，那么这个局部变量必须是*【有效**final**的】
\* 备注：从Java8+开始，只要局部变量事实不变，那么final关键字是可以省略的。
 
 原因：

1.new出来的对象在堆中。
 2.局部变量是跟着方法走的，在栈内存中。
 3.方法执行结束后，立刻出栈，局部变量会立即消失。
 4.但是new出来的对象会在堆当中持续存在，直到垃圾回收消失。

```
public class MyOuter {
    public void methodOuter(){
        /*final */int num=10; //所在方法的局部变量【有效final】
        class Inner{
            public void methodInner(){
                System.out.println(num);
            }
        }
    }
}
 
```

#### 六、匿名内部类的定义和使用

```
如果接口的实现类（或者是父类的子类）只需要使用一次，那么这种情况下就可以省略掉该类的定义，而改为使用【匿名内部类】。

定义格式：
    接口名称 对象名 = new 接口名称{
        //覆盖重写所有抽象方法
    };

对格式进行解析：
1.new代表创建对象的动作；
2.接口名称就是匿名内部类需要实现哪个接口；
3.{ ... }这才是匿名内部类的内容。

注意事项：
1.匿名内部类，在【创建对象】的时候，只能使用一次。
如果希望多次创建对象，而且类的内容一样的话，那么就必须使用单独定义的实现类了。
2.匿名对象，在【调用方法】时，只能使用唯一的一次。
如果希望同一个对象，调用多次方法，那么必须给对象起个名字。
3.匿名内部类是省略了【实现类/子类名称】，但是匿名对象是省略了【对象名称】。
//使用匿名内部类
MyInterface obj1=new MyInterface() {
    @Override
    public void method1() {
        System.out.println("匿名内部类方法1覆盖重写！111");
    }

    @Override
    public void method2() {
        System.out.println("匿名内部类方法2覆盖重写！222");
    }
};
obj1.method1();
obj1.method2();
 
//匿名内部类定义的匿名对象
new MyInterface(){
    @Override
    public void method1() {
        System.out.println();
    }

    @Override
    public void method2() {

    }
}.method1();
```

 

#### 七、类、接口作为成员变量类型，方法参数，返回值

```
public class Hero {
    private String name;  //英雄的名字
    private Weapon weapon; //英雄的武器
    private int age;  //英雄的年龄
}
 
接口作为成员变量：
//放入实现类的对象
SkillImpl skillImlp=new SkillImpl();
hero.setSkill(skillImlp);
System.out.println("=============");

//放入匿名内部类的对象
Skill skill=new Skill() {
    @Override
    public void use() {
        System.out.println("pia-pia-pia");
    }
};
hero.setSkill(skill);
System.out.println("=============");

//更简化的，放入匿名内部类的匿名对象
hero.setSkill(new Skill() {
    @Override
    public void use() {
        System.out.println("biu-pia");
    }
});
 
```

#### 八、发红包案例

普通红包（平均）

​                               

手气红包（随机红包）

 

 