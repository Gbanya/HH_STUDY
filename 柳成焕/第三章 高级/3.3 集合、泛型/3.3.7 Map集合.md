### 3.3.7 Map集合

#### 一、Map及常用子类概述

（一）java.util **Map**<K,V>集合
 特点：
   1.Map集合是一个双列集合，一个元素包含两个值（一个key，一个value）;
   2.Map集合中的元素，key和value的数据类型可以相同，也可以不同；
   3.key不允许重复，value可以重复。
   4.key和value是一一对应的。
 
 （二）java.util.**HashMap**<k,v>集合 implements Map<k,v>接口
 特点：
   1.HashMap集合底层是哈希表：查询速度非常快。
     JDK1.8之前：数组+单向链表
     JDK1.8之后：数组+单向链表/红黑树（链表长度超过8）：提高查询速度
   2.HashMap集合是一个无序的集合，存储元素和取出元素的顺序有可能不一致。
 
 （三）java.util.**LinkedHashMap**<k,v>集合 extends HashMap<k,v>集合
 特点：
   1.LinkedHashMap底层是哈希表+链表：保证迭代的顺序。
   2.是一个有序集合，存储元素和取出元素的顺序是一致的。

 

#### 二、Map接口中的常用方法

V **put**(K key, V value) 将指定的键与值添加到Map集合中。
  返回值：v
  存储键值对的时候，key不重复，返回值v是null；
  key重复，会使用新的value替换map中重复的value值，返回被替换的value值。
 V **get**(Object key) 根据指定的键，在map集合中获取对应的值。
  返回值：v
    key存在，返回对应的value值；不存在则返回null。
 V **remove**(Object key) 把指定的键所对应键值对元素，从map集合中删除，返回被删除的元素。
  返回值：v
    key存在，v返回被删除的值；key不存在，返回null。
 boolean **containsKey**(Object key) 判断集合中是否包含指定的键。
  包含返回true,不包含返回false。

#### 三、Map集合遍历键查找值

Map集合遍历：
 （一）第一种方式：键找值
 Set<K> keySet() 键找值，实现步骤：
   1.把Map集合找那个所有的key取出来存储到一个Set集合中；
   2.使用迭代器/增强for遍历Set集合，获取Map集合中的每一个key；
   3.使用Map集合的方法get(key)获取value。

```
//遍历方式1
Set<String> set = map.keySet(); //将key取出存储到set集合中
Iterator<String> it = set.iterator();//使用迭代器遍历键
while (it.hasNext()) {
    String key = it.next();
    Integer value = map.get(key);//使用get方法获取值
    System.out.println(key+"="+value);
}

System.out.println("=========");
//使用增强for遍历键
for (String key : set) {
    Integer value = map.get(key);
    System.out.println(key+"="+value);
}
```

 

（二）Entry键值对对象

Map集合的第二种遍历方式：
 Map.Entry<K,V>:在Map接口中有一个内部接口Entry
 作用：当Map集合一创建，就会在Map集合中创建一个Entry对象，用来记录键与值（键值对对象，键与值的映射关系）
 Set<Map.Entry<K,V>> entrySet() 实现步骤：
   1.使用Map集合中的entrySet()方法，把Map集合内部的多个Entry对象取出来存储到一个Set集合中；
   2.遍历Set集合中的每一个Entry对象；
   3.Entry对象中的方法：getKey()获取key，getValue()获取value

​                               

```
//创建集合存储entry对象
Set<Map.Entry<String,Integer>> set=map.entrySet();
//遍历set集合
Iterator<Map.Entry<String, Integer>> it=set.iterator();
while (it.hasNext()){
    Map.Entry<String, Integer> entry = it.next();
    String key=entry.getKey();
    Integer value=entry.getValue();
    System.out.println(key+"="+value);
}

System.out.println("==========");
for (Map.Entry<String, Integer> entry : set) {
    String key=entry.getKey();
    Integer value=entry.getValue();
    System.out.println(key+"="+value);
}
```

 

#### 四、HashMap存储自定义类型键值

  Map集合保证key是唯一的：作为key的元素，必须重写hashCode和equals方法，以保证key唯一。

```
/*
key：Person类型
   Person类型必须重写hashCode方法和equals方法，以保证key唯一
value：String类型
    value可以重复
 */
 private static void method02() {
     HashMap<Person, String> map = new HashMap<>();
     map.put(new Person("啊柳", 18), "厦门");
     map.put(new Person("王昭君", 17), "青海");
     map.put(new Person("李白", 20), "苏州");
     map.put(new Person("啊柳", 18), "昆明");
     System.out.println(map);
     //使用entrySet和增强for遍历
     Set<Map.Entry<Person, String>> set = map.entrySet();
     //使用增强for遍历
     for (Map.Entry<Person, String> entry : set) {
         Person key = entry.getKey();
         String value = entry.getValue();
         System.out.println(key + "=" + value);
     }
 }
```

 

#### 五、LinkedHashMap集合

java.util.LinkedHashMap<K,V> extends HashMap<k,v>
   Map接口的哈希表和链接列表实现，具有可预知的迭代顺序。
   底层原理：哈希表+链表（记录元素顺序）

```
HashMap<String,String>map=new HashMap<>();//key不允许重复，无序
map.put("d","d");
map.put("a","a");
map.put("c","c");
map.put("b","b");
map.put("a","d");
System.out.println(map);//{a=d, b=b, c=c, d=d}

LinkedHashMap<String,String> linkedMap=new LinkedHashMap<>();//key不允许重复，有序
linkedMap.put("d","d");
linkedMap.put("a","a");
linkedMap.put("c","c");
linkedMap.put("b","b");
linkedMap.put("a","d");
System.out.println(linkedMap); //{d=d, a=d, c=c, b=b}
```

 

#### 六、Hashtable集合

java.util.Hashtable<K,V>集合 implements Map<K,V>接口
 特点：
   1.Hashtable底层也是一个哈希表，是一个线程安全的集合，是单线程集合，速度慢
    HashMap底层是一个哈希表，是一个线程不安全的集合，是多线程集合，速度快
   2.HashMap集合（之前学的所有集合都）：可以存储null值，null键
    Hashtable集合：不能存储null值，null键
   3.Hashtable集合和Vector集合在JDK1.2版本之后被更先进的集合取代了（HashMap,ArrayList）
   Hashtable的子类Properties依然活跃在历史舞台，Properties是唯一一个和IO流相结合的集合。

#### 七、练习：计算一个字符串中每个字符出现的次数

思路：
 1.用Scanner类获取输入的字符串
 2.字符不能重复，个数可以重复，因此使用HashMap<Charcter,Interger>
 4.遍历字符串，获取每个字符
 5.遍历：字符串转为字符toCharArray;或者用length()+charAt()
 6.使用Map集合中的方法判断字符是否包含：containsKey,true则获取value，++，false则将（字符，1）添加到集合中
  使用集合的get方法，null说明key不存在，否则存在。

 

```
Scanner sc = new Scanner(System.in);
System.out.println("请输入一个字符串：");
String str = sc.next();

//定义一个HashMap集合
HashMap<Character, Integer> map = new HashMap<>();
char[] array = str.toCharArray();
for (int i = 0; i < array.length; i++) {
    if (map.get(array[i]) != null) {  //集合中包含该元素，则获取
        Integer value = map.get(array[i]);
        value++;
        map.put(array[i], value);
    } else {
        map.put(array[i], 1);
    }
}

//遍历输出
Set<Character> set = map.keySet();
for (Character key : set) {
    Integer value = map.get(key);
    System.out.println(key + "=" + value);
}
```

 

#### 八、JDK9对集合进行优化

List接口、Map接口、Set接口：增加了一个静态方法of，可以给集合一次性添加多个元素。
 static <E> list<E> **of**(E...elements)
 使用前提：当集合中存储的元素个数已经确定了，不再改变时使用。
 注意事项：
   1.of方法只适用于List接口、Map接口、Set接口，不适用于接口的实现类；
   2.of方法的返回值是一个不能改变的集合，集合不能再使用add，put添加元素，会抛出异常；
   3.Set接口和map接口在调用of方法时，不能有重复的元素，否则会抛出异常。

 

 

```
List<String> list = List.of("a", "b", "cc", "d");
System.out.println(list);  //[a, b, cc, d]
// list.add("1233"); //UnsupportedOperationException不支持操作异常
//Set<Integer> set=Set.of(10,2,34,10);//IllegalArgumentException非法参数异常，有重复的元素
Set<Integer> set = Set.of(10, 2, 34);
System.out.println(set);
//set.add(29);UnsupportedOperationException
//Map<String,Integer> map=Map.of("大乔",18,"小乔",15,"大乔",19);  IllegalArgumentException
Map<String, Integer> map = Map.of("大乔", 18, "小乔", 15);
System.out.println(map);
//map.put("张三", 20); //UnsupportedOperationException
```

 