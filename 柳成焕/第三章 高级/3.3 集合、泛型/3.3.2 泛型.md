### 3.3.2 泛型

#### 一、概念

当我们不知道使用什么数  据类型时，可以使用泛型。

也可以看成是一个变量，用于接收数据类型

E e :Element元素

T t：Type类型

​                               

 

#### 二、使用泛型的好处

（一）创建集合对象，不使用泛型
 好处：集合不使用泛型，默认类型就是Object类型，可以存储任意数据。
 弊端：不安全，会引发异常。
 （二）创建集合，使用泛型：
 好处：
 1.避免了类型转换的麻烦，存储的是什么类型，取出的就是什么类型；
 2.把运行期异常（代码运行之后会抛出的异常），提升到了编译期（写代码的时候就会报错）。
 弊端：泛型是什么类型，就只能存储什么类型（可以忽略）。

 

#### 三、泛型的定义与使用

```
定义：定义一个含有泛型的类，模拟ArrayList集合
public class Generic<E> {
    private E name;
    public Generic() {    }
    public Generic(E name) {    this.name = name;    }
    public E getName() {        return name;    }
    public void setName(E name) {        this.name = name;    }
}
```

使用：

```
//创建对象，泛型使用Integer
Generic<Integer>gc2=new Generic<>();
gc2.setName(100);
Integer name=gc2.getName();
System.out.println(name);

//创建对象，泛型使用String
Generic<String>gc3=new Generic<>();
gc3.setName("小明");
String name2=gc3.getName();
System.out.println(name2);
```

 

#### 四、定义和使用含有泛型的方法

定义含有泛型的方法：泛型定义在方法的修饰符和返回值之间。
 格式：*修饰符* *<**泛型>* *返回值类型* *方法名（参数列表（使用泛型）） {
\*     *方法体;
    }*
 含有泛型的方法，在调用方法的时候确定泛型的数据类型
 传递什么类型的参数，泛型就是什么类型。

```
//含有泛型的非静态方法
public  <E>void method1(E e){
    System.out.println(e);
}

//含有泛型的静态方法（调用时，直接使用类）
public static <S>void method2(S s){
    System.out.println(s);
}
```

 

 

#### 五、定义和使用含有泛型的接口

接口：

```
public interface GenericInterface<I> {
    public abstract void method(I i);
}
```

实现类1

```
定义含有泛型的接口的实现类，实现接口，并指定接口的泛型
public class GenericInterfaceImpl1 implements GenericInterface<String>{
    @Override
    public void method(String str) {
        System.out.println(str);
    }
}
```

实现类2

```
含有泛型的接口，第二种使用方式：接口使用什么泛型，实现类就使用什么泛型，类跟着接口走。
相当于定义了一个含有泛型的类，创建对象时指定泛型的类型。

public class GenericInterfaceImpl2<I> implements GenericInterface<I>{
    @Override
    public void method(I i) {
        System.out.println(i);
    }
}
```

主方法中：

```
//创建实现类1的对象（类型已经指定，之能是String）
GenericInterfaceImpl gil=new GenericInterfaceImpl();
gil.method("abd");
//创建实现类2的Integer对象
GenericInterfaceImpl2<Integer> gil2=new GenericInterfaceImpl2<>();
gil2.method(123);
//创建实现类2的Double对象
GenericInterfaceImpl2<Double> gil3=new GenericInterfaceImpl2<>();
gil3.method(200.0);
```

 

#### 六、泛型的通配符

（一）

泛型通配符： ？代表任意的数据类型
 使用方式：  不能创建对象使用，只能作为方法的参数使用。

```
//定义一个方法，能够遍历所有类型的ArrayList集合
public static void foreachArrayList(ArrayList<?> list) {
    Iterator<?> it = list.iterator();
    while (it.hasNext()) {
        Object obj = it.next();
        System.out.println(obj);
    }
}
```

 

（二）高级通配符

泛型的上限限定： ? extends E 代表使用的泛型只能是E类型的子类/本身
 泛型的下限限定： ? super  E 代表使用的泛型只能是E类型的父类/本身

 

### 3.3.3 斗地主综合案例

 

 

 

 