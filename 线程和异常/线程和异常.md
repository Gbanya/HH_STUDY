##1 异常
###什么是异常
  - 程序在执行过程中，出现的非正常的情况，最终会导致JVM的非正常停止。
  - Java等面向对象的编程语言中，异常本身是一个类，产生异常就是创建异常对象并抛出了一个异常对象。
### 异常产生的机制：
  当出现异常时,jvm会做两件事：
  - 根据异常产生原因,创建一个异常相关的对象，这个对象包含异常的产生的原因和位置
  - 如果jvm没有发现相应方法中解决异常相关的逻辑，则就会将异常抛出给方法的调用者处理<br>
  `注：异常对象的创建---throw new 异常对象();`
### 异常体系--Throwable
  - Throwable（最顶层）
    - 错误Error（`无法解决，必须修改源代码`):无法通过处理的错误，只能事先避免，好比绝症。
    - 异常Exception：
      - 编译时异常：(IOException、FileNotFoundException均继承至Exception，)不能通过编译，异常产生后程序员可以通过代码的方式纠正，使程序继续运行，是必须要处理的(try/catch,throws)。好比感冒、阑尾炎。
      - 运行时异常：(RuntimeException(ArrayIndexOutOfBoundsException等等)能通过编译，在程序执行时抛出的异常

### 异常的处理方式：
  - jvm处理异常的方式：<br>
  如果异常我们没有处理，jvm会帮我们处理，他会把异常的类型、原因还有位置显示在命令行并且还终止程序，后面代码不再执行
    - 人为处理方式：
      - 捕获处理:`try-catch`
      - 抛出去：`throw/throws`。
      当我们不想处理异常，或者没能力处理的时候可以抛出异常。谁调用方法，谁处理异常
    ```
     注1、如果出现多个异常，通常一次捕获，多次处理
         eg:
         try{

         }catch(异常1){
            处理1
         }catch(异常2){
            处理2
         }
     注2、catch(异常对象)中的异常对象如果存在子父类关系，优先处理子类异常。父类异常什么样，子类异常就什么样。其他不管
    ``` 
##2 线程
  - 线程和进程
    - 进程：`内存中正在运行的程序`。系统运行一个程序即是一个进程从创建、运行到消亡的过程
    - 线程：`进程中的一个执行单元`(应用程序的一个功能的通向cpu的路径)
    - 一个进程中至少有一个线程
    - 一个进程中是可以有多个线程的
    ```
    线程与进程补充：
      进程：有独立的内存空间，进程中的数据存放空间（堆空间和栈空间）是独立的，至少有一个线程。
      线程：堆空间是共享的，栈空间是独立的，线程消耗的资源比进程小的多。
    ```
  - 创建线程的方式
    - 继承Thread类：单继承局限性
    - 实现Runnable接口：扩展性更强
    - 线程池：避免线程重复创建、销毁，提高效率

## 线程同步
  - 线程安全：
    - 产生原因：
      - 要有多个线程
      - 要有被多个线程所共享的数据
      - 多个线程并发(交替)的访问共享的数据
    - 解决方案：针对共享数据代码
      - 同步代码块
      - 同步方法
      - 锁机制
    - 实现思路：
      1) 定义资源类：包括资源的属性和操作方法。`同步是添加在资源类的方法中，例如锁对象`
      2) 定义线程任务类（实现Runnable接口）：实现资源类方法调用。
      3) 创建线程对象Thread，传递任务，执行方法
  - 线程状态
    - 新建：new
    - 运行状态：Runnable
    - 锁阻塞：Blocked
    - 休眠(计时等待)：Timed Waiting
    - 无限等待：Waiting
    - 死亡：Terminated
  ```  
    注1:关于阻塞和休眠
      锁阻塞状态有执行资格，等待cpu空闲拿锁执行
      休眠状态放弃执行资格，cpu空闲也不会执行，除非被唤醒(自动或被动)
    注2：等待与唤醒:
      当线程沉睡(等待)，沉睡处的后续代码不继续执行。
      当沉睡(等待)的线程被唤醒，从沉睡的地方继续执行后续代码。
    注3：wait和sleep的区别？
      wait()：释放同步锁，其他线程能获取锁开始运行。
      sleep()：不释放锁，休眠的线程唤醒后接着运行。
  ```  
  - 应用场景：`生产者消费者`