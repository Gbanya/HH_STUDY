# HH_STUDY
## 分支学习： 
   ###             1、java8实战训练
   ###             2、springBoot的学习
   ###             3、大型网站架构学习
   ###             4、HR系统简易快速入门、第一阶段、基于内存和控制台的简历系统
   ###             5、设计模式
*  2020-07-02 
   -     第4分支：HR系统第一阶段基本完成，增加简历的增删改查功能。ArrayList<Resume> resumeList 存储简历对象
         分层架构：pojo:Resume简历对象；service:createResume、deleteResume、updateResume、selectResume;
         BUG:循环访问控制台输入流时，存在不等待输入的情况
             int choice = scanner.nextInt()-> java.util.NoSuchElementException
             考虑是由于控制台内程序自动输入空字符，导致出现异常。
* 2020-07-03 
   -     第1分支 java8实战 stream流的处理，基于管道的流的拼接，优化编程代码。
         第3分支 大型网站架构的高可用架构：分层模型
         第4分支 HR系统第二阶段基本完成，控制台版本基于txt文件的数据持久化。扩展ResumeService功能函数接口，为后续数据写入数据库做准备
* 2020-07-04
   -     第4分支 HR系统第三阶段，基于mysql数据库的数据持久化,新增简历
         基本工具：SpringBoot + Mybatis + Maven + Mysql
         插件：spring-boot-maven-plugin + mybatis-generator-maven-plugin               
         完成：1、利用mysql搭建本机数据库，整合idea+mysql，实现数据库可视化访问，简化方法测试。
               2、基于Mybatis实现对数据库的操作映射，将数据库表利用mybatis-generator-plugin插件生成dao层和pojo层对象
               3、基于junit单元测试框架，完成方法测试
               4、实现对数据库的增删改查
               5、搭建完成基本开发框架                           
         踩过的坑：
               1、Junit进行单元测试会自动回滚事务，导致输入数据插入成功却不存储，设置@Rollback(false)关闭事务回滚
               2、mybatis-generator-plugin生成*mapper.xml文件时，多次运行插件，会使xml文件方法重复而不是覆盖，运行时会报resultMap错误。解决方案：删掉重复方法的代码。   
* 2020-07-05
  -     第4分支 HR系统第三阶段基本完成，基于mysql数据库的数据持久化，完成简历的新增、删除、更新、查询。
        完成：1、基于数据库的简历增删改查功能
              2、完成功能的单元测试
        踩过的坑：
              之前基于mybatis-generator插件生成的mapper.xml文件缺少简历status元素，导致查询测试报错，修改排除。经验：基于mybatis-generator插件二次生成不覆盖导致问题频出，看之后插件版本可否改进，建议修改表字段后二次使用插件删除之前xml内容。
        下一步目标：
              完成cotroller层，尝试增加新模块服务功能，同时引入redis内存服务器，做到简历数据的批量缓存，以及快速读取。深入了解mybatis源码，工作原理。
              引入数据库连接池、为未来数据库并发访问做准备，了解各种类型数据库的源码及工作原理。
              考虑并发实战，搭建集群，主从数据库、分布式缓存完成基本项目需求。
* 2020-07-07
  -     第3分支 高可用的应用：1、通过负载均衡进行无状态服务的失效转移，通过负载均衡手段，将流量和数据分摊到一个集群组成的多台服务器上，以提高整体的负载处理能力
                             2、应用服务器集群的Session管理：Session复制、Session绑定、利用cookie记录Session、Session服务器
                高可用的服务：分级管理、超时设置、异步调用、服务降级、幂等性设计。详见脑图
        第5分支 程序设计模式： 工厂模式、抽象工厂模式、单例模式、装饰器模式。好的框架都采用了一定的设计模式让代码更简洁，看源码学习设计模式理解更深刻。详见脑图    
* 2020-07-09
  -     第4分支 数据库连接通过java-mysql-connector驱动方式连接，通过Driver驱动方式获取连接 connection =     DriverManger.getConnection()，获取连接，statement = connection.createStatement()获取连接通道，执行sql语句。
        缺点：没有事务管理。在多线程的情况下，每来一个线程新建一个连接，容易造成资源耗尽
        spring提供了声明式的事务管理方式 @Transaction。
        通过编程的方式实现@Transaction注解功能，利用了spring的IOC和AOP实现，加深对spring框架理解。
* 2020-07-14
  -     第4分支 基于控制台版本的hr_system，C/S系统基于Socket通信方式。

- 2020-07-20

  - **加锁的时候**
    - [对象头] ---->**标记字[mark word]**
      ![image-20200720103052205](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200720103052205.png)

  ​                  **age**--经历GC的次数--老年和新生
  
  ​                  **偏向锁状态位** -- 1 代表使用偏向锁 -- 0代表不使用偏向锁

  ![image-20200720103720053](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200720103720053.png)

  ​                  **lock**--2bit--[00]--无锁01、轻量锁00、重量锁10

  - **加锁的过程** -

  - 用了锁，但是没有争抢【**偏向锁**】

  - ![image-20200720104236746](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200720104236746.png)

     >类似场景：启动项目的时候，加载xxx功能，加载数据yy数据【 】

​               **第一次**加锁 ---->  CAS（比较和替换）判断threadID是否为空，把当前的线程ID设置上去

​               **第二次**同一个线程加锁---->和对象头里面保存的threadID直接判断【不修改任何数据】 

​               **偏向锁：偏向于某一个线程，加锁的时候，效率高**  【openjdk,jol包可以打印对象在内存中的数据】

​               **线程**---->   线程栈中保存有锁的信息 -栈中有lock record信息记录锁【释放锁之后，删除掉 】

- 锁已经偏向某一个线程，出现第二个**线程2**【**轻量级锁**】

  - 锁偏向的不是**线程2**【需要锁升级】   ---锁升级过程
    - **线程1**还在锁定中....    升级到**轻量级锁**定的 ，修改标记字内容
    - **线程1**释放锁....   升级到**无偏向无锁状态**

  - 轻量级锁 ----> 比较和替换（**CAS**操作）---如果当前的lock标记为**01无锁状态**，则修改为**00锁定状态**

    - **线程1先执行** --- **拿到锁**---1、修改状态位，对象markword执行线程 ；2、线程里边记录这个对象的信息

      ​                                           *释放锁  --- 反过来--- 1、修改状态为无锁状态；2、删除记录信息

    - **线程2后执行**---

      - 锁已经被释放 --- 1、该状态位，对象markword执行线程 ；2、线程里边记录这个对象的信息

      - 锁**没有释放**线程1仍然持有 ---  **锁膨胀**【重量级锁】  --- 【循环的重试 **自选**】

        现在的版本重试是有次数控制，JVM内部调整为**自适应**动态调整

  - 锁竞争激烈【**重量级锁**】 

    ```c++
    ObjectMonitor(){
    	_EntryList = NULL;
    	_Owner     = NULL;
    }
    ```

    - 重量级 --- 创建一个对象监视器
    - 加锁阻塞的过程 --- block线程状态切换 ---多线程上下文切换
    - 借助更底层操作系统内核提供的互斥锁相关的接口【】

  - **锁升级**：偏向锁 ----> 轻量级锁 ---->重量级锁 【**单向升级、无法降级**】