线程的6个状态
NEW 线程刚创建，未start之前
RUNNABLE  表示当前线程正在运行中。处于RUNNABLE状态的线程在Java虚拟机中运行，也有可能在等待其他系统资源
BLOCKED 阻塞状态。处于BLOCKED状态的线程正等待锁的释放以进入同步区
WAITING 等待状态。处于等待状态的线程变成RUNNABLE状态需要其他线程唤醒
TIMED_WAITING 超时等待状态。线程等待一个具体的时间，时间到后会被自动唤醒
TERMINATED 终止状态。此时线程已执行完毕

volatile仅能使用在变量级别,告诉jvm当前变量在寄存器中的值是不确定的，需要从主存中读取；(每次修改都要刷新主内存)
synchronized则可以使用在变量、方法、和类级别的。锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。
volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞。

乐观锁：每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在提交更新的时候会判断一下在此期间别人有没有去更新这个数据。
悲观锁：每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻止，直到这个锁被释放。

CAS：Compare and Swap，即比较再交换。
CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。
CPU去更新一个值，但如果想改的值不是之前的值，操作失败，因为明显有其它操作先改变了这个值。

atomic即多个线程同时对该变量的值进行更新时，仅有一个线程能成功，而未成功的线程继续尝试，一直等到执行成功。


创建线程有两种方法，
//一种是通过继承Thread方法。
public class ThreadTest extends Thread {
    @Override
    public void run() {
         try {
                    System.out.println("新的线程1")
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
    }
}

//一种是通过实现Runnable的接口
    public class RunnalbleTest implements Runnable {
        @Override
        public void run() {
               try {
                        System.out.println("新的线程2")
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
        }
    }
以上两种运行的run方法都没有返回值，想要让他有返回值可以通过Callable和Future创建线程

//Callable接口
import java.util.concurrent.*;

class Task implements Callable<Integer> {
    @Override
    public Integer call() throws Exception {
        return 1;
    }
    public static void main(String args[]){
            ExecutorService executor = Executors.newCachedThreadPool();
            Task task = new Task();
            Future<Integer> result = executor.submit(task) ;

        try {
            System.out.println(result.get());
        } catch (InterruptedException e) {
            e.printStackTrace();
        } catch (ExecutionException e) {
            e.printStackTrace();
        }
    }
}

//Future接口
public abstract interface Future<v>{
    public abstract boolean cancel( boolean paramBoolean) ;
    public abstract boolean isCancelled();
    public abstract boolean isDone();
    public abstract V get() throws InterruptedException, Execut ionException;
    public abstract V get(long paramLong, TimeUnit paramTimeUnit)
        throws InterruptedException, ExecutionException, TimeoutException;
}

//FutureTask

public interface RunnableFuture<v> extends Runnable,Future<V>{

    void run();
}

线程池原理：线程池做的工作主要是控制运行的线程的数量，处理过程中将任务放入队列，然后在线程创建后启动这些任务，
如果线程数量超过了最大数量,超出数量的线程排队等候，等其它线程执行完毕，再从队列中取出任务来执行。
