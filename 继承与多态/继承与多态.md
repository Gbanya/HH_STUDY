#继承
##面向对象三大特性：封装、继承、多态
###1 继承概述
- 继承解决的主要问题：`共性抽取`
    
- 继承的好处：`1、提高代码的复用性。 2、类与类之间产生了关系，是多态的前提`
- 继承的格式    
```
class 父类 { ...      }   
class 子类 extends 父类 { ...      }
```
###2 继承的特性
```
public class Fu {
    public int fu = 5;
    public int fu2 = 1;
    public void methodFu(){
        System.out.println("父类方法");
    }
    private void method(){
        System.out.println("父类的method");
    }
}
public class Zi extends Fu {
    public int fu = 10;
    @Override
    public void method() {
        System.out.println("子类的method:"+fu);
        System.out.println("子类的method:(super)"+super.fu);
    }
    public void methodFu(){
        System.out.println("子类的methodFu");
    }
}
```
- 成员变量:
  - 不重名：没有影响。子类可以直接调用父类非私有化成员变量
  - 重名：默认就近原则。但可以super调用父类同名的成员变量
```
Zi zi = new Zi();
System.out.println(zi.fu);//同名属性  10（子）
System.out.println(zi.fu2);//父类特有属性  1
```
- 成员方法
  - 不重名：没有影响。子类可以.....成员方法
  - 重名：调用的是子类的方法。
  - 注：子类继承方法的权限必须大于等于父类；public>protected>private
---
    *重写*:不同类中子类中方法声明与父类完全相同【有同样的方法名、返回值类型，参数列表】，但是子类的方法体不同，就叫方法重写。必须用@Override注释
    注：只能重写父类非私有方法
    *重载*:同类中同类中的方法名相同，但是参数列表不同。与返回值无关就叫方法重载
```
Zi zi = new Zi();
        System.out.println(zi.fu);
        System.out.println(zi.fu2);
        zi.method();
        zi.methodFu();
结果：
    10
    1
    子类的method:10
    子类的method:(super)5
    子类的methodFu
```
- 构造方法:`本类构造方法的入口是看new对象()中是否带参-->走哪个构造函数,进了构造函数后：`
    - 第一行有带参super(n),先调用对应的父类有参构造【方法重载】，再执行构造方法体
    - 第一行无带参super(n),
      - 第一行无带参this(n),默认先调用父类无参构造,再执行构造方法体
      - 第一行有带参this(n),先跳转到该this(n)对应的构造函数，然后判断第一行有无super(n),调用父类对应的有参或无参构造。再执行this(n)的对应的构造方法体，最后跳回第一次的构造方法体
    - this,super在构造函数第一行只能出现一个但无论是哪个出现,一定先执行父类构造函数
###3 抽象类
- 定义：由`abstract`修饰的，含有抽象方法的类。
- 特性：
  - 抽象类不能创建对象，如果创建，编译无法通过而报错。只能创建其非抽象子类的对象。
    - 理解：假设创建了抽象类的对象，调用抽象的方法，而抽象方法没有具体的方法体，没有意义。
  - 抽象类中，可以有构造方法，是供子类创建对象时，初始化父类成员使用的。
    - 理解：子类的构造方法中，有默认的super()，需要访问父类构造方法。 
  - 抽象类中，不一定包含抽象方法，但是有抽象方法的类必定是抽象类。
  - 抽象类的子类，必须重写抽象父类中所有的抽象方法，否则，编译无法通过而报错。除非该子类也是抽象类。
    - 理解：假设不重写所有抽象方法，则类中可能包含抽象方法。那么创建对象后，调用抽象的方法，没有意义。 

